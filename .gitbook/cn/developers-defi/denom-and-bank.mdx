---
title: Denom 元数据
---

`denom` 是代币在 Injective 的 `Bank` 模块中的表示方式。这些资产可用于交易、在 exchange 模块上创建新市场、参与拍卖、转账到另一个地址等。

开发者和交易者最大的痛点之一是获取这些 `denom` 的元数据。此元数据包括 `decimals`、`symbol`、`name` 等。

本指南展示了如何直接从 `injective-lists` 仓库获取 `denom` 元数据并将其映射到你的 `denom`。你也可以使用这种方法为现货和衍生品市场映射 `denom` 的元数据。

## Injective Lists

`injective-lists` 是一个公共仓库，保存 Injective 上所有代币的元数据信息。它是此特定信息最新和最可靠的来源。你可以通过为此仓库创建 PR 来提交你的代币信息。请确保正确指定字段。特别是，`"denom"` 字段（阅读关于[代币标准](/defi/tokens/)）应根据代币标准具有相应的 `ibc`、`peggy` 和 `factory` 前缀。

链上新 `denom` 的元数据每 30 分钟自动获取一次，`json` 文件会重新生成。

你可以前往 [https://github.com/InjectiveLabs/injective-lists/tree/master/json/tokens](https://github.com/InjectiveLabs/injective-lists/tree/master/json/tokens) 文件夹，根据环境下载元数据：

1. [主网原始 JSON](https://raw.githubusercontent.com/InjectiveLabs/injective-lists/refs/heads/master/json/tokens/mainnet.json)
2. [测试网原始 JSON](https://github.com/InjectiveLabs/injective-lists/blob/master/json/tokens/testnet.json)

获得 JSON 后，你必须将元数据与特定的 `denom` 映射。

此元数据信息的接口是

```typescript
export interface Token {
  name: string;
  logo: string;
  symbol: string;
  decimals: number;
  coinGeckoId: string;
  denom: string;
  address: string;
  tokenType: string;
  tokenVerification: string;
}
```

### Bank 余额

假设你获取特定地址的 bank 余额（如下面使用 TypeScript 的示例所示），你可以轻松地将其映射到上述 JSON 文件中的元数据信息

```typescript
import { config } from "dotenv";
import { getNetworkEndpoints, Network } from "@injectivelabs/networks";
import { ChainGrpcBankApi } from "@injectivelabs/sdk-ts/client/chain";
import { IndexerGrpcPortfolioApi } from "@injectivelabs/sdk-ts/client/indexer";

config();

/** 查询示例 */
(async () => {
  const endpoints = getNetworkEndpoints(Network.MainnetSentry);
  const chainGrpcBankApi = new ChainGrpcBankApi(endpoints.grpc);

  const injectiveAddress = "inj...";
  const { balances } = chainGrpcBankApi.fetchBalances(injectiveAddress);

  console.log(bankBalances);

 const metadata = JSON.parse(await readFile("./mainnet.json", "utf8")) as {
    denom: string;
    address: string;
    decimals: string;
    logo: string;
    name: string;
    tokenType: string;
    coinGeckoId: string
  }[];
  const balances = bankBalances.map((balance) => {
    const meta = metadata.find((m) => m.denom === balance.denom);

    return {
      ...balance,
      ...meta,
    };
  }

  console.log(balances)
})();
```

现在，你的 bank 余额拥有你需要的所有元数据信息（包括 `decimals`、`symbol`、`name`、`logo` 等）。

### 现货市场

与 Bank 余额类似，你可以使用相同的方法将现货市场中的 `denom` 与其元数据映射。

```typescript
import { config } from "dotenv";
import { readFile } from "fs/promises";
import { getNetworkEndpoints, Network } from "@injectivelabs/networks";
import { IndexerGrpcSpotApi } from "@injectivelabs/sdk-ts/client/indexer";

config();

/** 查询示例 */
(async () => {
  const endpoints = getNetworkEndpoints(Network.Testnet);
  const indexerGrpcSpotApi = new IndexerGrpcSpotApi(endpoints.indexer);

  const markets = await indexerGrpcSpotApi.fetchMarkets();

  console.log(markets);

  const metadata = JSON.parse(await readFile("./mainnet.json", "utf8")) as {
    denom: string;
    address: string;
    decimals: string;
    logo: string;
    name: string;
    tokenType: string;
    coinGeckoId: string;
  }[];
  const marketsWithMetadata = markets.map((market) => {
    const baseTokenMetadata = metadata.find(
      (m) => m.denom === market.baseDenom
    );
    const quoteTokenMetadata = metadata.find(
      (m) => m.denom === market.quoteDenom
    );

    return {
      ...market,
      baseTokenMetadata,
      quoteTokenMetadata,
    };
  });

  console.log(marketsWithMetadata);
})();
```

### 衍生品市场

与 Bank 余额类似，你可以使用相同的方法将衍生品市场中的 `denom` 与其元数据映射。

```typescript
import { config } from "dotenv";
import { readFile } from "fs/promises";
import { getNetworkEndpoints, Network } from "@injectivelabs/networks";
import { IndexerGrpcDerivativesApi } from "@injectivelabs/sdk-ts/client/indexer";

config();

/** 查询示例 */
(async () => {
  const endpoints = getNetworkEndpoints(Network.Testnet);
  const indexerGrpcDerivativeApi = new IndexerGrpcDerivativesApi(
    endpoints.indexer
  );

  const markets = await indexerGrpcDerivativeApi.fetchMarkets();

  console.log(markets);

  const metadata = JSON.parse(await readFile("./mainnet.json", "utf8")) as {
    denom: string;
    address: string;
    decimals: string;
    logo: string;
    name: string;
    tokenType: string;
    coinGeckoId: string;
  }[];
  const marketsWithMetadata = markets.map((market) => {
    const baseTokenMetadata = metadata.find(
      (m) => m.denom === market.baseDenom
    );

    return {
      ...market,
      quoteTokenMetadata,
    };
  });

  console.log(marketsWithMetadata);
})();
```
