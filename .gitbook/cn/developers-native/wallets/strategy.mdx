---
title: Wallet Strategy
---

`@injectivelabs/wallet-strategy` 的主要目的是为开发者提供一种在 Injective 上使用不同钱包实现的方式。所有这些钱包实现都暴露相同的 `ConcreteStrategy` 接口，这意味着用户可以直接使用这些方法，而无需了解特定钱包的底层实现，因为它们已被抽象化。

首先，你需要创建一个 `WalletStrategy` 类的实例，这使你能够开箱即用地使用不同的钱包。你可以通过在 `walletStrategy` 实例上使用 `setWallet` 方法来切换当前使用的钱包（注意：`setWallet` 是异步的，需要使用 `await`）。

让我们看看 `WalletStrategy` 策略暴露的方法及其含义：

**Ethereum 和 Cosmos 原生钱包通用：**

- `getAddresses` 从连接的 wallet strategy 获取地址。此方法为 Ethereum 原生钱包（strategies）返回 Ethereum 地址，为 Cosmos 原生钱包（strategies）返回 Injective 地址。
- `signTransaction` 使用相应的钱包类型方法签署交易（Cosmos 原生钱包使用 `signCosmosTransaction`，Ethereum 原生钱包使用 `signEip712TypedData`）
- `sendTransaction` 使用相应的钱包类型方法签署交易（如果要在 Ethereum 原生钱包上使用，需要在 options 中传递 `sentryEndpoint` - 解释见下文）
- `getWalletDeviceType` 返回钱包连接类型（mobile、browser、hardware）

**Cosmos 原生钱包：**

- `signCosmosTransaction` 使用连接的 wallet strategy 签署 Injective 交易
- `getPublicKey` 获取 Cosmos 原生 wallet strategies 的 public key

**Ethereum 原生钱包：**

- `getEthereumChainId` 获取 Ethereum 原生 wallet strategies 的 chain id
- `signEip712TypedData` 使用连接的 wallet strategy 签署 EIP712 typed data
- `sendEvmTransaction` 使用连接的 wallet strategy 发送 Ethereum Web3 交易
- `signEvmTransaction` 使用连接的 wallet strategy 签署 Ethereum Web3 交易
- `getEvmTransactionReceipt` 获取 wallet strategy 的 Ethereum 原生交易的 transaction receipt

### 参数

传递给 WalletStrategy 的参数具有以下接口：

```ts
export interface WalletStrategyEvmOptions {
  rpcUrl: string; // rpc url **仅**在 strategies 上的 Ethereum 原生方法需要
  evmChainId: EvmChainId; // 如果你使用 Wallet Strategies 签署 EIP712 typed data 则需要
}

export interface EthereumWalletStrategyArgs {
  chainId: ChainId; // Injective chain id
  evmOptions?: WalletStrategyEvmOptions; // 可选，仅在使用 Ethereum 原生钱包时需要
  disabledWallets?: Wallet[]; // 可选，如果你想禁用某些钱包的实例化则需要
  wallet?: Wallet; // 可选，初始选择的钱包（如果传递了 `evmOptions` 则默认为 Metamask，否则默认为 Keplr）
}
```

_注意：_ 当我们想在 Ethereum 原生钱包上使用 `sendTransaction` 时，除了其他选项（chainId 和 address）外，还需要传递一个 gRPC endpoint 到 sentry 来广播交易。这是必需的，因为从 Ethereum 原生钱包中，我们无法像 Keplr 或 Leap 那样访问 `broadcastTx` 方法来使用钱包的抽象广播交易，所以我们必须在客户端直接向链广播。

### 使用示例

```ts
import { TxRaw } from '@injectivelabs/sdk-ts/types'
import { Web3Exception } from '@injectivelabs/exceptions'
import { ChainId, EvmChainId } from '@injectivelabs/ts-types'
import { WalletStrategy } from '@injectivelabs/wallet-strategy'

const chainId = ChainId.Testnet // The Injective Testnet Chain ID
const evmChainId = EvmChainId.TestnetEvm // The Injective Evm Testnet Chain ID

export const evmRpcEndpoint = `https://eth-sepolia.g.alchemy.com/v2/${process.env.APP_EVM_RPC_KEY}`

export const walletStrategy = new WalletStrategy({
  chainId,
  evmOptions: {
    evmChainId,
    rpcUrl: evmRpcEndpoint,
  },
})

// 获取钱包地址
export const getAddresses = async (): Promise<string[]> => {
  const addresses = await walletStrategy.getAddresses()

  if (addresses.length === 0) {
    throw new Web3Exception(new Error('There are no addresses linked in this wallet.'))
  }

  return addresses
}

// 签署 Injective 交易
export const signTransaction = async (tx: TxRaw): Promise<string[]> => {
  const response = await walletStrategy.signCosmosTransaction(
    /*transaction:*/ { txRaw: tx, accountNumber: /* */, chainId: 'injective-1' },
    /*address: */ 'inj1...',
  )

  return response
}

// 发送 Injective 交易
export const sendTransaction = async (tx: TxRaw): Promise<string[]> => {
  const response = await walletStrategy.sendTransaction(
    tx,
    // 如果使用 Ethereum 钱包则需要 `sentryEndpoint`
    {address: 'inj1...', chainId: 'injective-1', sentryEndpoint: 'https://grpc.injective.network' }
  )

  return response
}
```
