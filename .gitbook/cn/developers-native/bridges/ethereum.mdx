---
title: 以太坊桥
---

Injective 以太坊桥使 Injective 链能够支持无需信任的链上双向代币桥。在这个系统中，以太坊上的 ERC-20 代币持有者可以即时将其 ERC-20 代币转换为 Injective 链上的 Cosmos 原生代币，反之亦然。

Injective Peggy 桥由三个主要组件组成：

1. 以太坊上的 Peggy 合约
2. Peggo 协调器
3. Injective 链上的 Peggy 模块

## Peggy 合约

Peggy 合约的功能是促进从以太坊到 Injective 链的 ERC-20 代币的高效双向跨链转移。与其他代币桥设置不同，Injective Peggy 桥是一个去中心化的、非托管的桥，完全由 Injective 上的验证者运营。该桥由 Injective 链的权益证明安全性保护，因为存款和取款是根据至少三分之二的验证者基于共识质押权力做出的证明来处理的。

## Peggo 协调器

协调器是每个 Injective 链验证者运行的链下中继器，其功能是将 ERC-20 代币转移数据从以太坊传输到 Injective 链。

## Peggy 模块

在基本层面上，Peggy 模块在从以太坊存入 ERC-20 时在 Injective 链上铸造新代币，并在从 Injective 链取回代币到以太坊时销毁代币。Peggy 模块还通过各种机制管理经济激励，以确保验证者诚实高效地行事，包括削减惩罚、原生代币奖励和取款费用。

## 从以太坊到 Injective

要从以太坊转移到 Injective，你需要进行 Web3 交易并与以太坊上的 Peggy 合约交互。完成转移需要两个步骤：

1. 由于我们基本上是将 ERC20 资产锁定在以太坊上的 Peggy 合约中，我们需要为要转移到 Peggy 合约的资产设置授权额度。你可以使用任何 web3 提供者（如 ethers.js 或 web3.js）调用 ERC-20 的 `approve` 函数，将 Peggy 合约地址作为支出者。
2. 设置授权额度后，我们需要在 Peggy 合约上调用 `sendToInjective` 函数，指定我们想要转移到 Injective 链的金额和资产。你可以使用 `@injectivelabs/contracts` 中的 `PeggyContract` 类（见下面的示例）或直接使用 ABI 与合约交互。交易确认后，资产将在几分钟内显示在 Injective 链上。

关于上述示例的几点说明：

- 目标地址（如果你想自己构建交易）格式如下：

```ts
"0x000000000000000000000000{此处填写不带0X前缀的以太坊地址}";
// 示例
"0x000000000000000000000000e28b3b32b6c345a34ff64674606124dd5aceca30";
```

其中以太坊地址是目标 Injective 地址对应的以太坊地址。

- `walletStrategy` 是我们构建的一个抽象，支持许多钱包，可用于签署和广播交易（在以太坊和 Injective 链上），更多详情可以在 npm 包 [@injectivelabs/wallet-strategy](https://github.com/InjectiveLabs/injective-ts/tree/master/packages/wallets/wallet-strategy) 和 [@injectivelabs/wallet-core](https://github.com/InjectiveLabs/injective-ts/tree/master/packages/wallets/wallet-core) 的文档中找到。显然，这只是一个示例，你可以直接使用 web3 包或任何 web3 提供者来处理交易。

```ts
import { PeggyContract } from "@injectivelabs/contracts";

const contract = new PeggyContract({
  ethereumChainId,
  address: peggyContractAddress,
  web3: web3 as any,
});
```

- 下面的代码片段实例化了一个 PeggyContract 实例，可以使用我们提供给合约构造函数的 `web3` 轻松地 `estimateGas` 和 `sendTransaction`。其实现可以在[这里](https://github.com/InjectiveLabs/injective-ts/blob/master/packages/contracts/src/contracts/Peggy.ts)找到。显然，这只是一个示例，你可以直接使用 web3 包 + 合约的 ABI 来实例化合约，然后使用某个 web3 提供者处理签署和广播交易的逻辑。

## 从 Injective 到以太坊

现在你已经将 INJ 的 ERC20 版本转移到了 Injective，Injective 链上的原生 `inj` 面额被铸造，它是 INJ 代币的规范版本。要从 Injective 取回 `inj` 到以太坊，我们必须在 Injective 链上准备、签署然后广播一个原生 Cosmos 交易。

如果你不熟悉 Cosmos 上的交易（和消息）如何工作，可以在这里找到更多信息。我们需要打包到交易中以指示 Injective 从 Injective 取款到以太坊的消息是 `MsgSendToEth`。

当在链上调用 `MsgSendToEth` 时，一些验证者会接收交易，将多个 `MsgSendToEth` 请求批量处理为一个，然后：在 Injective 上销毁被取回的资产，在以太坊上的 Peggy 智能合约上解锁这些资金并将它们发送到相应的地址。

这些交易中包含一个 bridgeFee，以激励验证者更快地接收和处理你的取款请求。bridgeFee 使用用户想要取回到以太坊的资产（如果你取回 INJ，你也必须用 INJ 支付 bridgeFee）。

以下是一个示例实现，准备交易，使用 privateKey 签署它，最后将其广播到 Injective：

```ts
import { getNetworkInfo, Network } from "@injectivelabs/networks";
import {
  TxClient,
  TxRestApi,
  createTransaction,
} from "@injectivelabs/sdk-ts/core/tx";
import {
  PrivateKey,
} from "@injectivelabs/sdk-ts/core/accounts";
import {
  MsgSendToEth,
} from "@injectivelabs/sdk-ts/core/modules";
import {
  ChainRestAuthApi,
} from "@injectivelabs/sdk-ts/client/chain";
import { toChainFormat, getDefaultStdFee } from "@injectivelabs/utils";

/** MsgSendToEth 示例 */
(async () => {
  const network = getNetworkInfo(Network.Mainnet); // 获取 rpc/lcd 端点
  const privateKeyHash =
    "f9db9bf330e23cb7839039e944adef6e9df447b90b503d5b4464c90bea9022f3";
  const privateKey = PrivateKey.fromPrivateKey(privateKeyHash);
  const injectiveAddress = privateKey.toBech32();
  const ethAddress = privateKey.toHex();
  const publicKey = privateKey.toPublicKey().toBase64();

  /** 账户详情 **/
  const accountDetails = await new ChainRestAuthApi(network.rest).fetchAccount(
    injectiveAddress
  );

  /** 准备消息 */
  const amount = {
    amount: toChainFormat(0.01).toFixed(),
    denom: "inj",
  };
  const bridgeFee = {
    amount: toChainFormat(0.01).toFixed(),
    denom: "inj",
  };

  const msg = MsgSendToEth.fromJSON({
    amount,
    bridgeFee,
    injectiveAddress,
    address: ethAddress,
  });

  /** 准备交易 **/
  const { signBytes, txRaw } = createTransaction({
    message: msg,
    pubKey: publicKey,
    fee: getDefaultStdFee(),
    sequence: parseInt(accountDetails.account.base_account.sequence, 10),
    accountNumber: parseInt(
      accountDetails.account.base_account.account_number,
      10
    ),
    chainId: network.chainId,
  });

  /** 签署交易 */
  const signature = await privateKey.sign(Buffer.from(signBytes));

  /** 附加签名 */
  txRaw.signatures = [signature];

  /** 计算交易哈希 */
  console.log(`交易哈希: ${TxClient.hash(txRaw)}`);

  const txService = new TxRestApi(network.rest);

  /** 模拟交易 */
  const simulationResponse = await txService.simulate(txRaw);

  console.log(
    `交易模拟响应: ${JSON.stringify(
      simulationResponse.gasInfo
    )}`
  );

  /** 广播交易 */
  const txResponse = await txService.broadcast(txRaw);

  if (txResponse.code !== 0) {
    console.log(`交易失败: ${txResponse.rawLog}`);
  } else {
    console.log(
      `已广播交易哈希: ${JSON.stringify(txResponse.txhash)}`
    );
  }
})();
```
