---
title: 以太坊桥
---

Injective 以太坊桥使 Injective 链能够支持无需信任的链上双向代币桥。在这个系统中，以太坊上的 ERC-20 代币持有者可以即时将其 ERC-20 代币转换为 Injective 链上的 Cosmos 原生代币，反之亦然。

Injective Peggy 桥由三个主要组件组成：

1. 以太坊上的 Peggy 合约
2. Peggo 协调器
3. Injective 链上的 Peggy 模块

## Peggy 合约

Peggy 合约的功能是促进从以太坊到 Injective 链的 ERC-20 代币的高效双向跨链转移。与其他代币桥设置不同，Injective Peggy 桥是一个去中心化的、非托管的桥，完全由 Injective 上的验证者运营。该桥由 Injective 链的权益证明安全性保护，因为存款和取款是根据至少三分之二的验证者（基于共识质押权重）的证明来处理的。

## Peggo 协调器

协调器是每个 Injective 链验证者运行的链下中继器，其功能是将 ERC-20 代币转移数据从以太坊传输到 Injective 链。

## Peggy 模块

在基本层面上，Peggy 模块在从以太坊存入 ERC-20 时在 Injective 链上铸造新代币，并在从 Injective 链提取代币回以太坊时销毁代币。Peggy 模块还通过各种机制（包括削减惩罚、原生代币奖励和提款费用）管理经济激励，以确保验证者诚实高效地行事。

## 从以太坊到 Injective

要从以太坊转移到 Injective，您必须进行 Web3 交易并与以太坊上的 Peggy 合约交互。进行转移需要两个步骤：

1. 由于我们基本上是将 ERC20 资产锁定在以太坊上的 Peggy 合约中，我们需要为要转移到 Peggy 合约的资产设置授权额度。您可以使用任何 web3 提供者（如 ethers.js 或 web3.js）调用 ERC-20 `approve` 函数，将 Peggy 合约地址作为支出者。
2. 设置授权额度后，我们需要使用要转移到 Injective 链的所需金额和资产调用 Peggy 合约上的 `sendToInjective` 函数。您可以使用 `@injectivelabs/contracts` 中的 `PeggyContract` 类（见下面的示例）或使用 ABI 直接与合约交互。交易确认后，资产将在几分钟内显示在 Injective 链上。

关于上述示例的几点说明：

- 目标地址（如果您想自己构建交易）的格式如下：

```ts
"0x000000000000000000000000{此处为不带0X前缀的以太坊地址}";
// 示例
"0x000000000000000000000000e28b3b32b6c345a34ff64674606124dd5aceca30";
```

其中以太坊地址是目标 Injective 地址对应的以太坊地址。

- `walletStrategy` 是我们构建的一个抽象，支持许多可用于签署和广播交易（在以太坊和 Injective 链上）的钱包，更多详情可以在 npm 包 [@injectivelabs/wallet-strategy](https://github.com/InjectiveLabs/injective-ts/tree/master/packages/wallets/wallet-strategy) 和 [@injectivelabs/wallet-core](https://github.com/InjectiveLabs/injective-ts/tree/master/packages/wallets/wallet-core) 的文档中找到。显然，这只是一个示例，您可以直接使用 web3 包或任何 web3 提供者来处理交易。

```ts
import { PeggyContract } from "@injectivelabs/contracts";

const contract = new PeggyContract({
  ethereumChainId,
  address: peggyContractAddress,
  web3: web3 as any,
});
```

- 下面的代码片段实例化了一个 PeggyContract 实例，可以使用我们提供给合约构造函数的 `web3` 轻松地 `estimateGas` 和 `sendTransaction`。其实现可以在[这里](https://github.com/InjectiveLabs/injective-ts/blob/master/packages/contracts/src/contracts/Peggy.ts)找到。显然，这只是一个示例，您可以直接使用 web3 包 + 合约的 ABI 来实例化合约，然后使用某些 web3 提供者处理签署和广播交易的逻辑。

## 从 Injective 到以太坊

现在您已经将 INJ 的 ERC20 版本转移到 Injective，Injective 链上的原生 `inj` 面额被铸造，它是 INJ 代币的规范版本。要从 Injective 提取 `inj` 到以太坊，我们必须准备、签署然后广播 Injective 链上的原生 Cosmos 交易。

如果您不熟悉 Cosmos 上的交易（和消息）如何工作，可以在这里找到更多信息。我们需要打包到交易中以指示 Injective 从 Injective 提取资金到以太坊的消息是 `MsgSendToEth`。

当在链上调用 `MsgSendToEth` 时，一些验证者将接收交易，将多个 `MsgSendToEth` 请求批量处理为一个，并：在 Injective 上销毁正在提取的资产，在以太坊上的 Peggy 智能合约上解锁这些资金并将它们发送到相应的地址。

这些交易中包含一个 bridgeFee，以激励验证者更快地接收和处理您的提款请求。bridgeFee 以用户想要提取到以太坊的资产计价（如果您提取 INJ，您也必须以 INJ 支付 bridgeFee）。

以下是准备交易、使用 privateKey 签署并最终广播到 Injective 的示例实现：

```ts
import { getNetworkInfo, Network } from "@injectivelabs/networks";
import {
  TxClient,
  TxRestApi,
  createTransaction,
} from "@injectivelabs/sdk-ts/core/tx";
import {
  PrivateKey,
} from "@injectivelabs/sdk-ts/core/accounts";
import {
  MsgSendToEth,
} from "@injectivelabs/sdk-ts/core/modules";
import {
  ChainRestAuthApi,
} from "@injectivelabs/sdk-ts/client/chain";
import { toChainFormat, getDefaultStdFee } from "@injectivelabs/utils";

/** MsgSendToEth 示例 */
(async () => {
  const network = getNetworkInfo(Network.Mainnet); // 获取 rpc/lcd 端点
  const privateKeyHash =
    "f9db9bf330e23cb7839039e944adef6e9df447b90b503d5b4464c90bea9022f3";
  const privateKey = PrivateKey.fromPrivateKey(privateKeyHash);
  const injectiveAddress = privateKey.toBech32();
  const ethAddress = privateKey.toHex();
  const publicKey = privateKey.toPublicKey().toBase64();

  /** 账户详情 **/
  const accountDetails = await new ChainRestAuthApi(network.rest).fetchAccount(
    injectiveAddress
  );

  /** 准备消息 */
  const amount = {
    amount: toChainFormat(0.01).toFixed(),
    denom: "inj",
  };
  const bridgeFee = {
    amount: toChainFormat(0.01).toFixed(),
    denom: "inj",
  };

  const msg = MsgSendToEth.fromJSON({
    amount,
    bridgeFee,
    injectiveAddress,
    address: ethAddress,
  });

  /** 准备交易 **/
  const { signBytes, txRaw } = createTransaction({
    message: msg,
    pubKey: publicKey,
    fee: getDefaultStdFee(),
    sequence: parseInt(accountDetails.account.base_account.sequence, 10),
    accountNumber: parseInt(
      accountDetails.account.base_account.account_number,
      10
    ),
    chainId: network.chainId,
  });

  /** 签署交易 */
  const signature = await privateKey.sign(Buffer.from(signBytes));

  /** 附加签名 */
  txRaw.signatures = [signature];

  /** 计算交易哈希 */
  console.log(`交易哈希: ${TxClient.hash(txRaw)}`);

  const txService = new TxRestApi(network.rest);

  /** 模拟交易 */
  const simulationResponse = await txService.simulate(txRaw);

  console.log(
    `交易模拟响应: ${JSON.stringify(
      simulationResponse.gasInfo
    )}`
  );

  /** 广播交易 */
  const txResponse = await txService.broadcast(txRaw);

  if (txResponse.code !== 0) {
    console.log(`交易失败: ${txResponse.rawLog}`);
  } else {
    console.log(
      `已广播交易哈希: ${JSON.stringify(txResponse.txhash)}`
    );
  }
})();
```
